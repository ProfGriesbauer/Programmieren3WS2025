using System;
using System.Collections.Generic;

namespace OOPGames
{
	// Einfacher Computer-Player für B5 TicTacToe.
	// Strategie:
	// 1) Suche einen Gewinnzug für sich
	// 2) Blockiere einen gegnerischen Gewinnzug
	// 3) Falls Mitte frei -> Mitte
	// 4) Zufällige leere Zelle
	public class B5_TicTacToeComputerPlayer : IComputerGamePlayer
	{
		private static readonly Random rng = new Random();

		public string Name => "B5 TicTacToe Computer";

		public int PlayerNumber { get; private set; }

		public bool CanBeRuledBy(IGameRules rules)
		{
			return rules is B5_GameRules;
		}

		public IGamePlayer Clone()
		{
			var c = new B5_TicTacToeComputerPlayer();
			c.SetPlayerNumber(PlayerNumber);
			return c;
		}

		public void SetPlayerNumber(int playerNumber)
		{
			PlayerNumber = playerNumber;
		}

		// Hauptfunktion: wähle einen gültigen Zug anhand des aktuellen Feldes
		public IPlayMove GetMove(IGameField field)
		{
			if (!(field is IB5_TicTacToeField tic)) return null;

			// 1) Gewinnzug finden
			if (TryFindTwoAndEmpty(tic, PlayerNumber, out int r, out int c))
			{
				return new B5_TicTacToeMove(PlayerNumber, r, c);
			}

			// 2) Gegner blocken
			int opponent = PlayerNumber == 1 ? 2 : 1;
			if (TryFindTwoAndEmpty(tic, opponent, out r, out c))
			{
				return new B5_TicTacToeMove(PlayerNumber, r, c);
			}

			// 3) Mitte bevorzugen
			if (tic.GetFieldValue(1, 1) == 0)
			{
				return new B5_TicTacToeMove(PlayerNumber, 1, 1);
			}

			// 4) Zufälliges freies Feld
			var empties = new List<(int r, int c)>();
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					if (tic.GetFieldValue(i, j) == 0) empties.Add((i, j));
				}
			}

			if (empties.Count == 0) return null;

			var pick = empties[rng.Next(empties.Count)];
			return new B5_TicTacToeMove(PlayerNumber, pick.r, pick.c);
		}

		// Hilfsfunktion: überprüft alle Reihen/Spalten/Diagonalen auf genau zwei Felder
		// des gegebenen Spielers und ein leeres Feld; gibt dieses Feld zurück.
		private bool TryFindTwoAndEmpty(IB5_TicTacToeField field, int targetPlayer, out int row, out int col)
		{
			row = col = -1;

			// Reihen
			for (int r = 0; r < 3; r++)
			{
				int count = 0, emptyCount = 0, emptyCol = -1;
				for (int c = 0; c < 3; c++)
				{
					int v = field.GetFieldValue(r, c);
					if (v == targetPlayer) count++;
					else if (v == 0) { emptyCount++; emptyCol = c; }
				}
				if (count == 2 && emptyCount == 1)
				{
					row = r; col = emptyCol; return true;
				}
			}

			// Spalten
			for (int c = 0; c < 3; c++)
			{
				int count = 0, emptyCount = 0, emptyRow = -1;
				for (int r = 0; r < 3; r++)
				{
					int v = field.GetFieldValue(r, c);
					if (v == targetPlayer) count++;
					else if (v == 0) { emptyCount++; emptyRow = r; }
				}
				if (count == 2 && emptyCount == 1)
				{
					row = emptyRow; col = c; return true;
				}
			}

			// Diagonale 1 (0,0)-(1,1)-(2,2)
			{
				int count = 0, emptyCount = 0, emptyIdx = -1;
				for (int i = 0; i < 3; i++)
				{
					int v = field.GetFieldValue(i, i);
					if (v == targetPlayer) count++;
					else if (v == 0) { emptyCount++; emptyIdx = i; }
				}
				if (count == 2 && emptyCount == 1)
				{
					row = emptyIdx; col = emptyIdx; return true;
				}
			}

			// Diagonale 2 (0,2)-(1,1)-(2,0)
			{
				int count = 0, emptyCount = 0, emptyRow = -1, emptyCol = -1;
				for (int i = 0; i < 3; i++)
				{
					int r = i, c = 2 - i;
					int v = field.GetFieldValue(r, c);
					if (v == targetPlayer) count++;
					else if (v == 0) { emptyCount++; emptyRow = r; emptyCol = c; }
				}
				if (count == 2 && emptyCount == 1)
				{
					row = emptyRow; col = emptyCol; return true;
				}
			}

			return false;
		}
	}
}

