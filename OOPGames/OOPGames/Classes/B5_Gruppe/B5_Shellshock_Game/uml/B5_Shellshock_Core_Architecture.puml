@startuml B5_Shellshock_Core_Architecture

title B5 Shellshock - Core OOP Architecture Overview\n(Structured Layout)

skinparam classAttributeIconSize 0
skinparam backgroundColor #FEFEFE
skinparam roundcorner 5
skinparam linetype ortho

left to right direction

' ====================================
' LEGEND
' ====================================

legend top left
  **OOP Concepts Demonstrated:**
  • Inheritance (Vererbung)
  • Interfaces (Schnittstellen)
  • Abstract Classes (Abstrakte Klassen)
  • Polymorphism (Polymorphie)
  • Encapsulation (Kapselung)
  • Design Patterns: Strategy, Factory, Template Method
end legend

' ====================================
' LAYER 1: INTERFACES (TOP)
' ====================================

package "Interfaces (Contracts)" #LightBlue {
    interface ICollidable {
        +CollidesWith(projectile) : bool
        --
        **Why:** Polymorphic collision
        **Benefit:** Any object can be hit
    }
    
    interface ITerrainGenerator {
        +Name : string
        +Generate(heightMap, width) : void
        --
        **Pattern:** Strategy
        **Why:** Swappable algorithms
    }
}

' ====================================
' LAYER 2: ABSTRACT CLASSES (MIDDLE)
' ====================================

package "Abstract Classes (Shared Behavior)" #LightYellow {
    abstract class GameEntity {
        #_x : double
        #_y : double
        #_isActive : bool
        --
        +{abstract} EntityType : string
        +X : double
        +Y : double
        +IsActive : bool
        +DistanceTo(other) : double
        --
        **Why:** Eliminate duplication
        **Shared:** Position & state
        **Enforces:** EntityType in subclasses
    }
    
    abstract class CollidableEntity {
        #{abstract} GetCollisionBounds() : Bounds
        +CollidesWith(proj) : bool
        --
        **Pattern:** Template Method
        **Why:** Shared algorithm, custom shapes
    }
}

package "Terrain Strategy (Abstract)" #LightYellow {
    abstract class TerrainGeneratorBase {
        +{abstract} Name : string
        +Generate(heightMap, width)
        #{abstract} GenerateRaw()
        #ApplySmoothing()
        --
        **Pattern:** Template Method
        **Pipeline:** Generate→Smooth→Clamp
    }
}

' ====================================
' LAYER 3: CONCRETE IMPLEMENTATIONS
' ====================================

package "Game Entities (Concrete)" #LightGreen {
    class Tank {
        -_angle : double [0-180]
        -_power : double [0-100]
        -_health : int [>=0]
        ==Encapsulation==
        --
        +Fire(player) : Projectile
        +TakeDamage(amount)
        +AdjustAngle(delta)
        #GetCollisionBounds() : Bounds
    }
    
    class Projectile {
        -_velocityX : double
        -_velocityY : double
        -_powerNorm : double
        --
        +UpdatePosition(gravity, wind, dt)
    }
    
    class HealthPack {
        +{static} HealAmount : int
        #GetCollisionBounds() : Bounds
    }
}

package "Terrain Generators (Concrete)" #LightGreen {
    class FlatTerrainGenerator {
        #GenerateRaw()
    }
    
    class HillTerrainGenerator {
        #GenerateRaw()
    }
}

package "Factory (Creation)" #Lavender {
    class TerrainGeneratorFactory {
        +{static} Create(type) : ITerrainGenerator
        +{static} CreateRandom() : ITerrainGenerator
    }
}

' ====================================
' LAYER 4: GAME MANAGEMENT (BOTTOM)
' ====================================

package "Game Management (MVC-like)" #LightCoral {
    class Field {
        -_tank1 : Tank
        -_tank2 : Tank
        -_terrain : Terrain
        -_projectile : Projectile
        -_healthPack : HealthPack
        --
        **Role:** Pure data container
    }
    
    class Rules {
        -_field : Field
        --
        +DoMove(move)
        +TickGameCall()
        +CheckIfPlayerWon() : int
        --
        **Role:** All game logic
    }
    
    class Painter {
        +PaintGameField(canvas, field)
        +TickPaintGameField(canvas, field)
        --
        **Role:** Pure rendering
    }
    
    class Terrain {
        -_generator : ITerrainGenerator
        -_heightMap : double[]
        --
        +GetHeightAt(x) : double
        +IsCollision(x, y) : bool
        +DestroyTerrain(x, radius)
    }
}

' ====================================
' VERTICAL INHERITANCE HIERARCHY
' ====================================

ICollidable <|.. CollidableEntity : implements

GameEntity <|-- CollidableEntity : extends
GameEntity <|-- Projectile : extends

CollidableEntity <|-- Tank : extends
CollidableEntity <|-- HealthPack : extends

ITerrainGenerator <|.. TerrainGeneratorBase : implements

TerrainGeneratorBase <|-- FlatTerrainGenerator : extends
TerrainGeneratorBase <|-- HillTerrainGenerator : extends

' ====================================
' HORIZONTAL ASSOCIATIONS
' ====================================

Field *-- "2" Tank
Field *-- "1" Terrain
Field *-- "0..1" Projectile
Field *-- "0..1" HealthPack

Rules *-- "1" Field
Painter ..> Field : reads

Terrain o-- "1" ITerrainGenerator : uses
TerrainGeneratorFactory ..> ITerrainGenerator : creates

Tank ..> Projectile : fires

' ====================================
' POSITIONED NOTES
' ====================================

note top of GameEntity
  **Abstract Base Class**
  • Cannot be instantiated
  • Forces subclasses to implement EntityType
  • Provides common position/state management
  
  **Eliminates code duplication:**
  Tank, Projectile, HealthPack all need X, Y, IsActive
end note

note bottom of CollidableEntity
  **Template Method Pattern**
  
  CollidesWith(projectile):
    1. Get bounds from subclass (polymorphic)
    2. Check if projectile in bounds (shared logic)
  
  **Why:** Tank has rectangle, HealthPack has square
  Each overrides GetCollisionBounds() differently
end note

note right of ITerrainGenerator
  **Strategy Pattern**
  
  Terrain doesn't know HOW to generate
  It just calls generator.Generate()
  
  **Benefit:**
  • Add new terrain types easily
  • Swap algorithms at runtime
  • No modification to Terrain class
end note

note bottom of Field
  **Separation of Concerns**
  
  Rules = Logic (physics, collisions, AI)
  Field = Data (tanks, terrain, projectiles)
  Painter = View (rendering)
  
  **MVC-like pattern**
  Clean separation enables testing
end note

note right of Tank
  **Encapsulation Example**
  
  public double Angle {
    get => _angle;
    set => _angle = Clamp(value, 0, 180);
  }
  
  **Invariant enforced:**
  Impossible to create invalid angle
end note

@enduml
